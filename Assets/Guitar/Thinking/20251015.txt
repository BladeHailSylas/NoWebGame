CoreMotor2D를 만들었다
BattleCore도 있다
구조도 대강 파악했다

그럼 뭘 해야 하는가?
엔터티를 생성해보면 된다
엔터티가 생성되어 잘 작동하는지 확인하면 고비를 대부분 넘긴 거다
왜? 그건 우리가 지금껏 의존했던 Unity Components를 대부분 닦아냈다는 거니까

주로 의존했던 Unity Components는 다음과 같다:
Transform, Rigidbody2D, Collider2D, Vector2

놀랍게도 KinematicMotor2D는 이 모든 걸 쓰고 있었고, 그렇기에 이걸 아예 새로 만들어야 했던 것
그런데 그렇게 갈아엎은 CoreMotor2D가 이제 제대로 작동한다?
이건 이제 "어떻게 Unity Components를 안전하게 제거하나?" 를 답할 수 있다는 것

그걸 답할 수 있다면 나머지는 "이 구조대로 refactoring이 필요해" 라고 AI에게 맡기면 해주니까 더없이 쉽다
다소 삐걱거리는 부분이 있더라도 로직은 내가 다 파악하고 있으니 새로운 구조에 맞게 또 만들면 그만이다

어쩌면 PlayerStats를 수정해야 할 것 같다, Entity의 하위로 두고 Region으로 묶는 것도 방법일까?
아니면 몇 가지를 Struct로 설정한다? AttackData { int BaseAttackDamage; int AttackDamage; ...} 처럼?
이건 가능할 수도 있겠으나 Struct는 값 수정이 어려워서 힘들다, Base stats는 일단 정해지면
 불변이므로 전부 Struct로 묶을 수는 있겠다

1. The World가 엔터티를 생성한다
2. 그걸 플레이어에게 쓰라고 준다, 단 이건 플레이어가 직접 가져가는 게 아니라 "네 입력은 이 엔터티에 영향을 가하게 될 거야" 라는 선언이다
3. PlayerLocomotion의 MoveIntent가 "내가 영향을 가하는 이 엔터티를 이렇게 움직이려 한다" 라는 선언을 전달하게 만든다
4. IntentCollector를 만든다, IntentCollector가 매 틱 모든 Intent를 모아 BattleCore에 전달할 거다
5. BattleCore는 Intent의 availability를 검사한다, 안 되는 Intent는 Orchestrator에 전달하지 않고 버린다
6. Orchestrator가 MoveIntent를 받았다: Intent를 해석하여 CoreMotor2D에 넘긴다
7. CoreMotor2D는 "이 엔터티를 이렇게 움직여야 한다" 를 받아서 실행시킨다, 모두가 행복하다

플레이어가 엔터티를 가져가는 건 약간 보드게임처럼 생각해도 될 것 같다
파티형 보드게임을 보면 서로 다른 말 여러 개가 있고 그 중에 내가 원하는 걸 조종한다
그렇다고 그게 영원히 내 거는 아니다, 그저 당장 내가 그 말에 영향을 가하고 있는 것에 불과하다
거기다 모든 말은 사실 서로 다르지 않다, 구분 가능하게 만든 외형(색깔, 스티커 등)을 제외하면 모든 말의 기능이 똑같다
생각해 보라, 인생게임을 하는데 어떤 말은 사람 5개만 끼워지고 어떤 말은 7개나 끼워진다면 그게 제대로 된 인생게임인가
단지 보드게임에서는 주로 색깔이나 스티커 모양새로 말을 구분하지만 여기서는 Entity ID로 구분한다

CPU의 입력은 어떻게 하나?
내가 보기에 나는 제대로 된 AI를 만들 수 없으니 그냥 if if if로 처리해야 할 것 같다(이게 AI의 본질이기는 하다)
단 CPU는 오직 로컬 PvE에서만 존재할 수 있기에 Player의 SkillIntent(입력-실행에 대략 2프레임 정도 딜레이가 발생할 것이다)를 보고 무빙으로 피한다
3v3 PvE? CPU 사이의 Interaction은 아직은 잘 모르겠다(나에게 너무 많은 짐을 지우지 말라, 애초에 PvE도 주력이 아니거늘)
어쩌면 로컬에서 SkillIntent 생성 시에 그 히트박스를 미리 띄워보고 지금 맞을 상황인지 판정할 수 있을 듯
그리고 기술 버튼 입력 시에 즉발로 나가는 게 아니고 LoL처럼 떼야 발동했으면 좋겠다
Determinism 확보 후에 생각해야 할 이야기는 맞지만 일단 떠올랐기에 적는다
모든 Hitbox가 원이나 사각형으로 생성되기에 판정 범위 미리 띄우는 건 아마 어렵지 않을 것이다

그리고 매치 종료 시 자동 큐를 추가하는 것도 괜찮을 것 같다
꽤 짧은 게임이라 한 번 할 때 여러 판 즐기고 싶을 텐데 매번 수동으로 큐 돌리면 귀찮을 거다
반면 중간에 쉬고 싶은데도 자동으로 큐가 돌아가는 것도 싫을 테니 약간 시간을 주는 게 좋다
내가 생각하기에 꽤 쓸 만한 방법이 있다, 자동 큐는 플레이어를 바로 Enqueue하지 않고 일부러 약간 시간을 두고 큐에 들여보내는 거다
모두가 딜레이 후 큐에 들어가므로 사실상 불공정하지 않다, 서버에서는 원래대로 큐 받으면 매치 잡는 거라서 비용도 크지 않다
그런데 그게 너무 길면 플레이어가 불쾌하므로 대략 2~5초 사이가 적당할 것 같다(개인적으로 2초가 좋아 보인다)
이건 테스트 시의 실제 게임 템포를 보고 결정하자, 만약 그냥 5초 박았는데 게임이 25초만에 끝나면 좀 길다고 느껴질 거다
자동 큐 나가고 수동 큐 돌려서 조금 더 빨리 잡는 건 개인의 선택이므로 딱히 막을 생각 없다(자동 큐를 사용하지 않는 옵션은 따로 추가해주자)


그런데 생각보다 개발에 진전이 없다
쓸데없이 파이프라인 단일화한다고 시간 까먹고 네트워크 PvP 만든다고 시간 까먹고
그냥 보여주는 게 목적인 프로젝트였으면 이미 연출 생각하고 있을 시간이었다
어쩌면 그냥 너무 완벽주의에 매몰되었을지도 모름
완벽한 구조 -> 완벽한 시스템 -> 완벽한 게임
이 흐름을 원했건만 능력 부족인지 완벽한 구조도 못 만들었다
그럼 어떻게 해야 하나요?
일단 완벽한 구조는 거의 다 넘은 산이므로 무조건 완성해야 된다
그 뒤에는 완벽을 포기하든가 건강을 포기하면 된다
아마 AI의 올바른 사용으로 생산성이 훨씬 향상되고 나의 실력도 아주 좋다면 3개월안에 그럴싸한 게임 만드는 건 불가능하지 않다
근데 그건 내 생각에 어렵다, 집에 가서도 일하고 주말에도 일해야 할 것이다
그런데 솔직히 코드는 거의 안 보이기 때문에 아무리 엔진에 집중하더라도 뭔가 결과물은 나와야 한다
그러므로 엔진에 집중할 계획이라면 확장성을 크게 신경써야 한다
확장성 => 실제 구현이 될 수도 있으므로 아마 다음으로는 확장성을 고려해야 할 것 같다
이미 게임 시스템에 대해서는 어느 정도 확장성이 있다
FollowUp 스택을 Params에 배정하고 단일 파이프라인을 통하게 한 것이나 Lockstep core 같은 게 그러하다
아무튼 슬슬 작업 열망이 꺼져가고 있기에 결단의 준비가 필요한 시점이라고 본다

원래 예정 따라가는 프로젝트는 없다지만 이건 예정과 너무 멀리 벗어났다
애초에 인프라 자체를 뒤집어야 할 거라고 예상하지 못했다
Dash를 만들다 충돌 문제를 고쳐야 해 KinematicMotor2D를 만들었고, KinematicMotor2D를 고치니 SkillRunner 오류가 보였다
SkillRunner를 고치려니 Intent 방식이 필요했고 Intent 방식을 실현하니 Intent Orchestrator가 필요했다(이때쯤 determinism을 생각했을 것이다)
Intent Orchestrator 관련해서 오류가 계속 나니 침체에 빠졌고, 그러다 추석을 맞아 쉰 후에 코드를 다시 보니 꽤 거지같았다
Determinism을 진지하게 계획한 건 10월 10일, 즉 저번 주 금요일인데 그때는 방향이 명확하지 않아 꽤 헤메었다
결국 13일에 Determinism을 위한 Core 시스템을 제대로 머릿속에 그리기 시작해서 그때부터 14일까지 refactoring을 시도했다
그런데 이미 Unity 의존성이 미쳐 날뛰고 있어서 refactoring이 제대로 안 됐고 구국의 결단으로 CoreMotor2D를 만들었다
CoreMotor2D를 만들고 EntityData 같은 걸 만들면서 진정으로 코어 엔진을 만들고 있다가 "이건 너무 느리지 않나" 하는 생각이 든 것
사실 위를 보면 코어 엔진을 만들려고 한 것도 꽤 진심이었는데 갑자기 사고의 전환