해야 할 거 정리

BattleCore를 만들어서 로직을 결정적으로 만든다(핵심)
ㄴ Lockstep에 있어 가장 중요한 게 바로 이거임, 상대의 입력을 내가 받아도 똑같은 결과를 낼 수 있어야지
  ㄴ 어차피 게임은 로컬에서 돌리게 되어있으니 로컬이 아닌 상대와 로컬처럼 대전하려면 상대의 입력이 로컬에 들어와야 됨
     ㄴ 그리고 로컬로 들어온 데이터가 진짜 로컬에서 입력한 것처럼 작동해야 함, 즉 로컬 멀티와 온라인 멀티가 이론상 똑같아야 함

KinematicMotor2D를 대거 수정한다(Vector2 => FixedVector2, Collider2D 제거 등)
ㄴ 이동은 선형적이어서 determinism을 확보하기 용이한 편이지만, 그렇기에 바로 determinism을 가장 먼저 확보해야 함
  ㄴ 이동은 게임플레이의 근원으로 플레이어 엔터티의 위치를 변경하는 가장 일반적인 방법이기에 필요하다
    ㄴ 거기다 Dash도 이 Motor의 파이프라인을 타기에(다만 일반적인 이동보다 속력이 훨씬 빠를 뿐) 필수적으로 수정해야 한다

다른 모든 Mechanism의 Collider2D를 제거한다
ㄴ 이건 상대적으로 쉬울 수도 있는데, 내가 보기에 Projectile은 조금 문제일 수도 있음
  ㄴ 하지만 딱 한 가지 바꾸는 건 AI가 얼마든지 할 수 있으니 큰 문제는 없을 것, 해결해야 할 문제는 차고 넘침

TargetingRuntimeUtil의 Towards Movement를 고친다
ㄴ 얘는 지금 owner.GetComponentInChildren을 그대로 쓰고 있음
  ㄴ 그런데 이건 옛날 방식, 지금 이 방식을 시도하면 대상이 무조건 null임(앵커가 안 만들어질 가능성도 있는데, Toawrds Cursor는 잘 되므로 이건 아닐 수도 있음)
    ㄴ Player가 기본적으로 움직일 때 그 방향으로 앵커를 생성하도록 하든가, 이동이 선형적이니까 delta normalized로 방향을 결정할 수도 있을 것
       ㄴ 아무튼 방향을 결정하는 게 문제로 보임, 그런데 어떤 방법이든 Vector2를 사용하니까(not deterministic) FixedVector2로 일단 바꾸고 나서 다시 짚어야 함

Towards Entity인데 적절한 대상이 없으면 앵커를 만듦
ㄴ 어쩌면 TargetingRuntimeUtil의 개조가 필요한 부분일지도 모름

CastScope 없이 FollowUp을 생성할 수 없음: 원래는 이게 맞는데 FollowUp이 없어도 이 Warning이 나온다
ㄴ CastScope를 다루는 방법을 알아와야 할 수 있음, 이쪽 코드는 분석이 부족해서 뭐가 뭔지도 모르겠고 건들기도 어려운 상태
  ㄴ 헌데 IntentOrchestrator가 BattleCore 안에 들어가야 하니까 당장 진행해야 할 일이 아님

위의 문제가 해결될 경우 아래를 해야 함

Mechanism 추가
ㄴ 냉정하게 말해 지금 상태는 도저히 게임 같지 않음, Melee / Projectile / Dash / Switch 밖에 가진 게 없으므로 추가가 진행되어야 함
  ㄴ 그런데 아무것도 모르면서 추가한다는 것도 넌센스, CastScope 및 IntentOrchestrator 등을 분석하고 난 후에 추가가 필요

Primitive enemy 추가
ㄴ 로컬에서 상대를 조작하거나, 디버그 옵션을 통해 상대를 조작할 수 있는 컨트롤러가 필요하다
  ㄴ 이건 딱히 어렵지 않음, 기존의 모듈을 사용하되 대상을 상대로 바꾸는 것이므로
    ㄴ 여기서 봐야 할 건 그 Primitive enemy가 입력을 제대로 받아서 수행하는가, 그것만 밝혀지면 통신 대전도 더없이 손쉬운 것
(10/15) 콘솔에 Intent를 생성하도록 명령을 넣을 수 있으면 좋은데 그게 어려우므로 다른 방법을 생각해야 한다
(10/15) 어쩌면 다른 임시 엔터티가 Intent를 대신 생성해줄 수 있겠다, 네트워크에서 패킷으로 Intent를 입력받는 것을 테스트할 수도 있을 것이다

이펙트(VFX/SFX) 추가
ㄴ 이건 좀 나중에 해야 할 건데 일단 고려해야 함
  ㄴ 근데 우선순위는 진짜 낮을 듯, 무엇보다 지금 컴퓨터는 소리를 들을 방법이 없음
    ㄴ 즉 어느 정도 때가 되었다 생각이 들면 장착 가능한 이어폰 같은 걸 사서 만들게 될 것


추가로 Lockstep 동기화에 대해서도 고찰이 필요하다
예를 들어 A가 60t(틱) 1s, B가 60t 1.1s라고 하자
그러면 A는 10초에 600틱에 도달하는데 B는 11초에 600틱에 도달한다
즉 B가 600틱일 때 A는 660틱이므로 A 입장에서 B는 60틱의 오차를 가진다

이게 작아 보여도 우리 게임의 TTK는 대략 10~20초이므로 1초 오차도 굉장한 차이
결국 느린 B에게 A가 맞춰주는 게 꽤 이상적이다, 뱁새가 황새 따라가려면 가랑이 찢어지니까
그런데 무작정 A한테 "야야, 아직 601틱 시작 안 할 거야. 너 좀 기다려." 하고 순간순간 딜레이를 걸어버리면 A는 게임 하기 싫다
결국 게임은 집중을 기울여야 하는데 툭툭 끊겨버리면 집중에 방해가 되기 때문

그러면 대략 두 가지 방법이 있는데, 딜레이를 체감할 수 없게 만들거나 딜레이를 없애면 된다
딜레이를 숨기려면 B의 인터벌에 A의 인터벌을 맞추면 된다
애초에 인터벌이 1.1s가 되어버리면 초당 틱이 거의 비슷하기 때문에 동기화 과정에서 끊을 일이 없다
다만 문제는 상대에 따라 게임이 빨라지거나 느려지거나 한다는 것
60t 1.1s인 상대에게 맞춰버리면 게임이 평균 10% 느려지는 거다, 이게 별 거 아닌 것 같아도 하면 할수록 은근히 체감이 될 수 있음

추가로 이 인터벌을 샘플링하는 방법에 대해서도 생각할 필요가 있는데 여긴 좋은 방법이 있다
매치 성사 후 게임 개시 시에 인게임 화면에 연출을 띄운다
철권이나 스파, 킹오파 등에서 나오는 ROUND 1 FIGHT! 같은 느낌이다, 다만 이건 격겜이 아니니까 적당히 간략한 연출을 띄운다
1~2초 남짓한 시간이지만 네트워크 품질이 어느 정도 균일하다면 그동안 낸 평균으로도(최대편차를 쓰라는데 고려해보자) 꽤 적절하게 맞을 것이다
거기다 조작 불가한 타이밍에 샘플링해서 인터벌 동기화를 진행하므로 실제 조작 가능한 동안에는 이미 동기화된 상태라 불편하지 않다

그러면 딜레이를 없애는 방법은 뭔가? 바로 인터벌 그룹을 만드는 거다
애초에 인터벌을 모르는 사람과 만나기 때문에 인터벌 차이가 날 수 있고, 그렇기에 차이를 안 나게 하려면 서로의 인터벌을 알면 된다는 것
예를 들어 60t 1s, 60t 1.15s, 60t 1.3s처럼 그룹을 나눠서 매치메이킹을 하는 사람들을 가장 가까운 그룹에 들어가게 한다
60t 1s라면 1s그룹, 60t 1.4s라면 1.45s그룹에 들어가서 1s인 사람과 1.4s인 사람은 절대 만나지 않는다
즉 1s(원래 틱 레이트)에 가까운 사람들은 가까운 사람들끼리 만나므로 인터벌 오차가 별로 없다
인터벌 오차가 큰 사람들은 서로 만나지 않으니 상대가 아무리 인터넷이 느려도 상관이 없다

그런데 여기서 문제가 있는데, 그룹별로 매치를 가지게 만들면 매치메이킹이 오래 걸릴 수 있다
매치메이킹이 생각보다 오래 걸릴 경우(평균 시간 + 25%) 1그룹 차이의 상대를 만날 수 있게 한다
추가로 여기서도 딜레이를 완전 제거할 수 없으므로 딜레이를 숨기는 방법도 함께 적용할 수 있다
어차피 딜레이가 적으므로 숨기는 한 거의 체감이 안 되고, 1그룹 차이의 상대까지는 허용 가능한 선이라고 생각
아니면 지수함수적으로 접근해서 걸린 시간에 비례해 인터벌 차이가 나는 상대를 만나게 할 수도 있다
그런데 이 방법은 그냥 유저 풀이 적은 시간대에 적절치 못한 상대를 임의로 잡아버릴 수도 있으므로 좀 조심스럽다

prediction + rollback에 관한 이야기도 들었는데 지금은 딱히 관심이 없음
무엇보다 좀 어려울 듯, 지금 구현하는 것도 머리 깨지겠는데 여기에 뭘 더 얹는 건 미친 짓 같음
스스로 떠올린 아이디어도 아니고 들은 이야기라서 딱히 머릿속에 그려지지도 않는데, 그릴 수 없다는 건 구현할 수 없다는 것
머릿속에 떠오르는 이미지도 구현하는 데 애먹는 현실인데 모르겠는 걸 구현한다고 까불다 뭐가 되겠는가


히트스톱도 조금 생각할 필요가 있겠다, 원래 연출은 맨 마지막에 생각하는 것이지만 이건 네트워크와 직결된 거니까
공격 후 딜레이 동안에는 움직일 수 없으니, 히트 스톱 동안 밀린 프레임을 여기서 보간한다
강한 공격 = 큰 후딜 = 강한 역경직

히트스톱 동안에는 나만 멈춘다, 나는 프레임이 밀리는데 다른 사람들은 너무도 자유롭다
여기서 히트스톱 동안에 움직일 수 없는 이유를 선사하지 않으면 역경직 큰 기술이 쓰레기가 된다
어쩌면 공격 후딜이 도움이 될 수 있다, 공격이 닿았을 때는 아직 공격 판정 발생 중이라는 뜻
여기서 후딜은 반드시 공격 판정 발생 후에 올 수밖에 없다, 만약 이후에 FollowUp이 온다 해도 무관
왜냐면 어차피 FollowUp도 능동적으로 발동할 수 없기 때문, 오히려 FollowUp 시전 시 + 시전 후 덕에 더 안전

헌데 밀린 프레임을 어떻게 보간하는가? 이건 생각보다 단순한 일이다
그냥 후딜 동안에 밀린 프레임을 전부 재생시키면 그만이다
여기서 중요한 건 프레임 재생이다, 재생하는 게 원래 프레임 인터벌이랑 똑같으면 어쨌든 프레임이 밀린다
그래서 밀린 프레임을 재생하는 동안에는 조금 빨리 재생시킨다, 어차피 흐름이 중요하지 몇 초에 어떻게 되었는지 중요치 않기 때문

아니 액션 게임에서 몇 초에 어떻게 되었는지 안 중요하다는 게 무슨 말인가요?
정해진 인터벌이 있는데 프레임을 그렇게 막 땡겨도 되나요? 
여기서는 안 중요한 거 맞고 막 땡겨도 된다
원래 인터벌은 새로운 상태가 업데이트되는 주기로, 서로가 똑같이 업데이트를 가져야 하기에 인터벌 보정이 필수적이었다
그런데 이건 상황이 다르다, 이미 업데이트된 상태를 재생하는 것에 불과하니 아무리 빨라도 문제가 없다
유튜브 실시간 스트리밍은 2배속으로 못 보는데, 그 스트리밍 다시보기는 2배속 쓸 수 있는 것과 동일하다

사실 이 아이디어는 원래 Party Animals에서 reference를 따왔다
적어도 그렇다고 생각을 했다
그런데 Party Animals는 공격자에게 히트스톱을 안 건다, 오직 넉다운을 당할 때에만 히트스톱이 걸린다
사실 이것도 꽤 영리한 방법이기는 한데, 어차피 넉다운 도중에는 도저히 움직일 수 없으니 얼마나 딜레이를 먹이든 상관이 없다
어차피 못 움직이니 다시 일어날 때까지(혹은 그대로 죽을 수도 있지만) 프레임 보간으로 인터벌을 정상화하는 건 굉장히 합리적이다

문제는 그 방법 같으면 공격자에게 타격감이 없다는 것, 그런데 우리는 액션 게임이라 공격자에게 타격감이 있었으면 좋겠다
거기서 몬헌의 방법을 추가로 떠올리게 됐는데, 몬헌은 강한 공격일수록 역경직이 크게 걸린다
문제는 몬헌식 역경직은 진짜로 못 움직이는 거라서 이거 때문에 몬스터한테 맞아죽는다
거기다 이거 PvP 액션 게임인데 여기다 "때리면 못 움직임"을 넣는 순간 역경직 약한 연타형 캐릭터가 신이 된다
PvP는 철저히 이득 보는 싸움이어야 하고, 그 기본은 프레임 싸움인데 거기서 격차가 나면 이만한 망겜이 없음

거기서 떠올린 게 바로 '강한 공격 = 큰 후딜 = 강한 역경직' 공식
후딜 동안에는 어차피 못 움직여서 아무리 히트스톱을 걸어도 괜찮다
거기다 히트스톱이 후딜 내내 걸리는 게 아니고 언젠가 모든 프레임이 resolve될 것이기에 인터벌 정상화도 가능하다
수학적인 과정을 통해 괜찮은 그래프만 구하면(정적분이 도움이 될 것이다) 후딜 끝나기 전에 모든 프레임을 resolve 가능하다
(10/14) 그래프의 정적분(t1 => t2) 값이 Δt와 똑같게(즉, truth와 local time을 일치시키게: 기하적으로는 사각형 모양을 만든다) 그래프를 만들면 된다고 본다
(10/14) 히트스톱 시간에 따라 그래프를 다르게 할 필요성도 생각할 수 있다, 하지만 일단 히트스톱을 완성하고 고려해 볼 일
그래프를 그리는 건 내가 하지 않고 AI의 도움을 빌린다 모터 얏타!


그렇게 생각하면 모든 행동을 Intent 처리하는 것도 이해가 가는 부분
"나 이거 행동한다" 라고 선언하고 바로 행동하게 되면 막기가 좀 어렵다
사실 이 경우 상대와 자신에게 좀 비대칭성이 있다, 상대는 나한테 입력을 전달하는데 나는 직접 실행하니까
내 입장에서는 상대가 Stun을 먹고 행동하면 안 되는데 해석의 차이로 상대가 행동했다면 게임 하기 싫을 거다
PvP 게임의 제1원칙은 공정성이고, 비대칭성은 종종 공정하지 않다(사실 꽤 많은 경우에 불공정하다)

그런데 "나 행동 좀 할 건데 그래도 돼?" 하고 물어보면 좀 이야기가 다르다
왜냐면 Core가 안 되는 행동을 막으면 실제 실행되지 않고, 그러면 불공정하지 않다
이건 로컬에서 직접 행동을 막는 것과 천지 차이로 속일 수 있는 여지가 거의 없다

약간 초등학생 피구처럼 생각하면 된다, 원래 살짝이라도 닿으면 죽는 건데 안 닿았고 안 죽었다고 우긴다
아무리 봐도 닿았는데 개개인의 양심에 맡기게 되면 아무도 이 상황에서 안 죽을 것이다
그런데 심판이 나선다면? 심판에게 게임 룰에 관련한 모든 판단을 맡긴다면?
심판이 죽었으니 나가라 하면 빠져야 된다, 이론상 모든 명령은 심판이 최종적으로 허가하기 때문
공에 맞은 사람이 죽었다고 스스로 나가는 건 심판이 뭐라고 안 한다, 이건 의도에 일치하는 결과니까
그런데 공에 맞아놓고 안 죽었다고 우기면 강제로 끌어내야 하고 이게 Core의 궁극적인 목적이다

아니면 그냥 Core를 엄마라고 보면 된다
애들 둘이서 장난감 하나 가지고 싸운다, 서로 누가 먼저 잡았네 누구 차례네 하면서 말이다
이때 엄마가 온다, 엄마는 애들의 말을 듣고 어떤 애가 장난감을 잡을 자격이 있는지 분간한다
애들은 엄마의 말을 따를 수밖에 없다, 엄마는 가장 논리적이며 권위는 엄마에게 있다
애들이 서로 사이좋게 뭘 할 때 엄마가 안 건드는 건 그냥 엄마가 굳이 그 행동을 불허할 이유가 없기 때문이다

즉 문제가 없으면 Core는 사실 그냥 전달자다, 자신의 Intent와 상대의 Intent를 받아 Orchestrator에게 넘기는 전달자
그런데 문제가 생기면 Core의 말을 따를 수밖에 없으며, 그러지 않으면 공정한 게임은 절대 성립할 수 없다
그럼 Orchestrator는? 애들 원하는 거 해주는 아빠다
애들이 원하는 게 있으면 엄마는 "여보, 애들이 뭘 해달라는데..." 처럼 아빠한테 이야기한다
이건 엄마가 아이들의 행동을 허가하는 것이며, 아빠는 엄마의 허가가 떨어진 모든 걸 해준다
엄마가 허가하면 아빠가 맛있는 거 사주고, 아빠가 장난감 사주고, 아빠가 놀이공원 같이 가 준다
근데 아빠는 결국 엄마 편이라 엄마 말을 거스르지 않는다, 엄마가 안 된다고 하면 죽어도 안 되는 거다
다시 말해 엄마가 최강이며 엄마가 가장 위대하다, 모든 길은 엄마를 통한다